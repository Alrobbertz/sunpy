"""
Facilities to interface with the Heliophysics Events Knowledgebase.
"""
import json
import codecs
import urllib
import inspect
from itertools import chain

import astropy.table
from astropy.table import Row

import sunpy.net._attrs as core_attrs
from sunpy import log
from sunpy.net import attr
from sunpy.net.base_client import BaseClient, QueryResponseTable
from sunpy.net.hek import attrs
from sunpy.net.hek.utils import freeze, parse_times, parse_values_to_quantities
from sunpy.util import dict_keys_same, unique
from sunpy.util.xml import xml_to_dict

__all__ = ['HEKClient', 'HEKTable', 'HEKRow']

DEFAULT_URL = 'https://www.lmsal.com/hek/her?'

class HEKClient(BaseClient):
    """
    Provides access to the Heliophysics Event Knowledgebase (HEK).

    The HEK stores solar feature and event data generated by algorithms and
    human observers.

    Notes
    -----
    The columns ``event_coord1``, ``event_coord2`` and ``event_coord3``
    are megred into one `astropy.coordinates.SkyCoord` object under the column ``event_coord``.

    Furthermore, we create following coordinate systems corresponding to each the following columns:

    * `~astropy.coordinates.ICRS`.

        * ``bound_chaincode``: Provides coordinates in the ICRS frame using boundary chaincode.
        * ``skel_chaincode``: Provides coordinates in the ICRS frame using skeleton chaincode.

    * `~sunpy.coordinates.frames.HeliographicCarrington`.

        * ``hgc_bbox``: Represents the bounding box coordinates in the Heliographic Carrington (HGC) coordinate system.

        * ``hgc_coord``: Provides specific coordinates in the HGC coordinate system.

        * ``hgc_boundcc``: Uses boundary chaincode to provide coordinates in the HGC coordinate system.

    * `~sunpy.coordinates.Helioprojective`.

        * ``hpc_bbox``: Provides bounding box coordinates in the Helioprojective coordinate system (HPC).

        * ``hpc_coord``: Specifies coordinates in the HPC frame.

        * ``hpc_boundcc``: Uses boundary chaincode to specify coordinates in the HPC coordinate system.

    * `~sunpy.coordinates.HeliographicStonyhurst`.

        * ``hgs_bbox``: Represents the bounding box coordinates in the Heliographic Stonyhurst (HGS) coordinate system.

        * ``hgs_coord``: Provides specific coordinates in the HGS coordinate system.

        * ``hgs_boundcc``: Uses boundary chaincode to provide coordinates in the HGS coordinate system.

    * `~sunpy.coordinates.Heliocentric`.

        * ``hrc_bbox``: Represents the bounding box coordinates in the Heliocentric coordinate system (HRC).

        * ``hrc_coord``: Specifies coordinates in the HRC frame.

        * ``hrc_boundcc``: Uses boundary chaincode to specify coordinates in the HRC coordinate system.

    References
    ----------
    * `Heliophysics Knowledge Base Feature/Event Types definitions <https://www.lmsal.com/hek/VOEvent_Spec.html>`__
    """
    # FIXME: Expose fields in .attrs with the right types
    # that is, not all StringParamWrapper!

    default = {
        'cosec': '2',  # Return .json
        'cmd': 'search',
        'type': 'column',
        'event_type': '**',
    }
    # Default to full disk.
    attrs.walker.apply(attrs.SpatialRegion(), {}, default)

    def __init__(self, url=DEFAULT_URL):
        self.url = url

    def _download(self, data):
        """ Download all data, even if paginated. """
        page = 1
        results = []
        new_data = data.copy()
        # Override the default name of the operatorX, where X is a number.
        for key in data.keys():
            if "operator" in key:
                new_data[f"op{key.split('operator')[-1]}"] = new_data.pop(key)
        while True:
            new_data['page'] = page
            url = self.url + urllib.parse.urlencode(new_data)
            log.debug(f'Opening {url}')
            fd = urllib.request.urlopen(url)
            try:
                result = codecs.decode(fd.read(), encoding='utf-8', errors='replace')
                result = json.loads(result)
            except Exception as e:
                raise OSError("Failed to load return from the HEKClient.") from e
            finally:
                fd.close()
            results.extend(result['result'])
            if not result['overmax']:
                if len(results) > 0:
                    table = astropy.table.Table(dict_keys_same(results))
                    table = parse_times(table)
                    table = parse_values_to_quantities(table)
                    return table
                else:
                    return astropy.table.Table()
            page += 1


    def search(self, *args, **kwargs):
        """
        Retrieves information about HEK records matching the criteria
        given in the query expression. If multiple arguments are passed,
        they are connected with AND. The result of a query is a list of
        unique HEK Response objects that fulfill the criteria.

        Examples
        -------
        >>> from sunpy.net import attrs as a, Fido
        >>> timerange = a.Time('2011/08/09 07:23:56', '2011/08/09 12:40:29')
        >>> res = Fido.search(timerange, a.hek.FL, a.hek.FRM.Name == "SWPC")  # doctest: +REMOTE_DATA
        >>> res  # doctest: +SKIP
        <sunpy.net.fido_factory.UnifiedResponse object at ...>
        Results from 1 Provider:
        <BLANKLINE>
        2 Results from the HEKClient:
                 SOL_standard          active ... skel_startc2 sum_overlap_scores
        ------------------------------ ------ ... ------------ ------------------
        SOL2011-08-09T07:19:00L227C090   true ...         None                  0
        SOL2011-08-09T07:48:00L296C073   true ...         None                  0
        <BLANKLINE>
        <BLANKLINE>
        """
        query = attr.and_(*args)
        data = attrs.walker.create(query, {})
        ndata = []
        for elem in data:
            new = self.default.copy()
            new.update(elem)
            ndata.append(new)

        if len(ndata) == 1:
            return HEKTable(self._download(ndata[0]), client=self)
        else:
            return HEKTable(self._merge(self._download(data) for data in ndata), client=self)

    def _merge(self, responses):
        """ Merge responses, removing duplicates. """
        return list(unique(chain.from_iterable(responses), freeze))

    def fetch(self, *args, **kwargs):
        """
        This is a no operation function as this client does not download data.
        """
        return NotImplemented

    @classmethod
    def _attrs_module(cls):
        return 'hek', 'sunpy.net.hek.attrs'

    @classmethod
    def _can_handle_query(cls, *query):
        required = {core_attrs.Time}
        optional = {i[1] for i in inspect.getmembers(attrs, inspect.isclass)} - required
        qr = tuple(x for x in query if not isinstance(x, attrs.EventType))
        return cls.check_attr_types_in_query(qr, required, optional)


class HEKRow(Row):
    """
    Handles the response from the HEK. Each HEKRow object is a subclass
    of `~astropy.table.Row`. The column-row key-value pairs correspond to the
    HEK feature/event properties and their values, for that record from the
    HEK.  Each HEKRow object also has extra properties that relate HEK
    concepts to VSO concepts.
    """
    @property
    def vso_time(self):
        return core_attrs.Time(
            self['event_starttime'],
            self['event_endtime']
        )

    @property
    def vso_instrument(self):
        if self['obs_instrument'] == 'HEK':
            raise ValueError("No instrument contained.")
        return core_attrs.Instrument(self['obs_instrument'])

    @property
    def vso_all(self):
        return attr.and_(self.vso_time, self.vso_instrument)

    def get_voevent(self, as_dict=True,
                    base_url="http://www.lmsal.com/hek/her?"):
        """Retrieves the VOEvent object associated with a given event and
        returns it as either a Python dictionary or an XML string."""

        # Build URL
        params = {
            "cmd": "export-voevent",
            "cosec": 1,
            "ivorn": self['kb_archivid']
        }
        url = base_url + urllib.parse.urlencode(params)

        # Query and read response
        response = urllib.request.urlopen(url).read()

        # Return a string or dict
        if as_dict:
            return xml_to_dict(response)
        else:
            return response

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default


class HEKTable(QueryResponseTable):
    """
    A container for data returned from HEK searches.
    """
    Row = HEKRow
